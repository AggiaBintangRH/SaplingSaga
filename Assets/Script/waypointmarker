using UnityEngine;
using UnityEngine.UI;

public class WaypointManager : MonoBehaviour
{
    public Transform targetObject; // The object the waypoint points to
    public Camera playerCamera; // VR or main camera

    // The UI Image for the arrow sprite
    public Image arrowImage;

    // Assign the arrow sprites in the inspector
    public Sprite arrowLeft;
    public Sprite arrowRight;
    public Sprite arrowUp;
    public Sprite arrowDown;

    // The UI marker for the canvas
    public RectTransform waypointMarker; // The UI marker on the canvas
    public RectTransform canvasRect; // Reference to the canvas rect to keep the marker within bounds

    // Define the size of the box in front of the player
    public float minboxWidth = 200f;  // Width of the box in pixels
    public float maxboxWidth = 200f;  // Width of the box in pixels
    public float minboxHeight = 200f; // Height of the box in pixels
    public float maxboxHeight = 200f; // Height of the box in pixels


    void Update()
    {
        // Get the position of the target relative to the player's camera
        Vector3 screenPoint = playerCamera.WorldToScreenPoint(targetObject.position);

        // Determine if the target is behind the player
        bool isBehind = screenPoint.z < 0;

        // Get the direction to the target in local space relative to the player
        Vector3 localTargetPosition = playerCamera.transform.InverseTransformPoint(targetObject.position);

        // Determine the arrow direction
        if (isBehind)
        {
            // If behind, only show left or right arrow
            if (localTargetPosition.x < 0)
            {
                arrowImage.sprite = arrowLeft;
            }
            else
            {
                arrowImage.sprite = arrowRight;
            }
        }
        else
        {
            // Target is in front of the player, determine exact direction
            if (Mathf.Abs(localTargetPosition.x) > Mathf.Abs(localTargetPosition.y))
            {
                // Target is more to the left or right
                if (localTargetPosition.x < 0)
                {
                    arrowImage.sprite = arrowLeft;
                }
                else
                {
                    arrowImage.sprite = arrowRight;
                }
            }
            else
            {
                // Target is more up or down
                if (localTargetPosition.y > 0)
                {
                    arrowImage.sprite = arrowUp;
                }
                else
                {
                    arrowImage.sprite = arrowDown;
                }
            }
        }

        // Get the player's position in screen space
        Vector3 playerScreenPosition = playerCamera.WorldToScreenPoint(playerCamera.transform.position);

        // Calculate the center position for the clamp box based on the player's forward direction
        Vector3 boxCenter = playerScreenPosition + playerCamera.transform.forward * 100; // Adjust 100 to set how far in front of the player the box should be


        // Clamp the marker position within the defined bounds
        screenPoint.x = Mathf.Clamp(screenPoint.x, minboxWidth, maxboxWidth);
        screenPoint.y = Mathf.Clamp(screenPoint.y, minboxHeight, maxboxHeight);

        // Convert screen position to canvas position
        Vector2 canvasPos;
        RectTransformUtility.ScreenPointToLocalPointInRectangle(canvasRect, screenPoint, playerCamera, out canvasPos);

        // Set the marker position on the canvas
        waypointMarker.anchoredPosition = canvasPos;
    }
}
